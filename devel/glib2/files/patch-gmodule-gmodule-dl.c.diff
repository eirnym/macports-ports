--- gmodule/gmodule-dl.c.orig	2020-10-12 11:21:02.000000000 +0200
+++ gmodule/gmodule-dl.c	2020-10-12 11:22:08.000000000 +0200
@@ -19,10 +19,10 @@
  * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
  * file for a list of people on the GLib Team.  See the ChangeLog
  * files for a list of changes.  These files are distributed with
- * GLib at ftp://ftp.gtk.org/pub/gtk/. 
+ * GLib at ftp://ftp.gtk.org/pub/gtk/.
  */
 
-/* 
+/*
  * MT safe
  */
 #include "config.h"
@@ -116,7 +116,7 @@
    * does not work reliable and generally no symbols are found
    * at all. RTLD_DEFAULT works though.
    * On Android 64 bit, dlopen(NULL) seems to work but dlsym(handle)
-   * always returns 'undefined symbol'. Only if RTLD_DEFAULT or 
+   * always returns 'undefined symbol'. Only if RTLD_DEFAULT or
    * NULL is given, dlsym returns an appropriate pointer.
    */
 #if defined(__BIONIC__)
@@ -133,13 +133,18 @@
 static void
 _g_module_close (gpointer handle)
 {
-#if defined(__BIONIC__)
-  if (handle != RTLD_DEFAULT)
-#endif
-    {
-      if (dlclose (handle) != 0)
-	g_module_set_error (fetch_dlerror (TRUE));
-    }
+  /* Intentionally not dlclose()ing because it is safer to leave the library
+   * loaded in memory than to close it and possibly leave dangling pointers
+   * to things like atexit handlers, atfork handlers, blocks, etc.
+   *
+   * See https://trac.macports.org/ticket/45309 for an example from when
+   * a library used by a module added a new dependency which had an
+   * initializer which added a child atfork handler.  The result is that
+   * after closing the module, the system had a dangling pointer for the
+   * atfork handler which would at best crash on the child side of fork()
+   * and at worst lead to arbitrary code execution of whatever happened to be
+   * at that location in memory at a later time in the process.
+   */
 }
 
 static gpointer
